;; WASIX Preview. This is an enhanced version the API that WASI initially
;; launched with.
;;
;; Some content here is derived from [CloudABI](https://github.com/NuxiNL/cloudabi).
;;
;; This is a `witx` file. See [here](https://github.com/WebAssembly/WASI/tree/master/docs/witx.md)
;; for an explanation of what that means.

(use "typenames.witx")

(module $wasix_module_name
  ;;; Linear memory to be accessed by WASI functions that need it.
  (import "memory" (memory))

  ;;; Read command-line argument data.
  ;;; The size of the array should match that returned by `args_sizes_get`.
  ;;; Each argument is expected to be `\0` terminated.
  (@interface func (export "args_get")
    (param $argv (@witx pointer (@witx pointer u8)))
    (param $argv_buf (@witx pointer u8))
    (result $error (expected (error $errno)))
  )
  ;;; Return command-line argument data sizes.
  (@interface func (export "args_sizes_get")
    ;;; Returns the number of arguments and the size of the argument string
    ;;; data, or an error.
    (result $error (expected (tuple $size $size) (error $errno)))
  )

  ;;; Read environment variable data.
  ;;; The sizes of the buffers should match that returned by `environ_sizes_get`.
  ;;; Key/value pairs are expected to be joined with `=`s, and terminated with `\0`s.
  (@interface func (export "environ_get")
    (param $environ (@witx pointer (@witx pointer u8)))
    (param $environ_buf (@witx pointer u8))
    (result $error (expected (error $errno)))
  )
  ;;; Return environment variable data sizes.
  (@interface func (export "environ_sizes_get")
    ;;; Returns the number of environment variable arguments and the size of the
    ;;; environment variable data.
    (result $error (expected (tuple $size $size) (error $errno)))
  )

  ;;; Return the resolution of a clock.
  ;;; Implementations are required to provide a non-zero value for supported clocks. For unsupported clocks,
  ;;; return `errno::inval`.
  ;;; Note: This is similar to `clock_getres` in POSIX.
  (@interface func (export "clock_res_get")
    ;;; The clock for which to return the resolution.
    (param $id $clockid)
    ;;; The resolution of the clock, or an error if one happened.
    (result $error (expected $timestamp (error $errno)))
  )

  ;;; Return the time value of a clock.
  ;;; Note: This is similar to `clock_gettime` in POSIX.
  (@interface func (export "clock_time_get")
    ;;; The clock for which to return the time.
    (param $id $clockid)
    ;;; The maximum lag (exclusive) that the returned time value may have, compared to its actual value.
    (param $precision $timestamp)
    ;;; The time value of the clock.
    (result $error (expected $timestamp (error $errno)))
  )
  
  ;;; Sets the time value of a clock.
  ;;; Note: This is similar to `clock_settime` in POSIX.
  (@interface func (export "clock_time_set")
    ;;; The clock for which to set the time.
    (param $id $clockid)
    ;;; The value of the time to be set.
    (param $timestamp $timestamp)
    ;;; The time value of the clock.
    (result $error (expected (error $errno)))
  )

  ;;; Provide file advisory information on a file descriptor.
  ;;; Note: This is similar to `posix_fadvise` in POSIX.
  (@interface func (export "fd_advise")
    (param $fd $fd)
    ;;; The offset within the file to which the advisory applies.
    (param $offset $filesize)
    ;;; The length of the region to which the advisory applies.
    (param $len $filesize)
    ;;; The advice.
    (param $advice $advice)
    (result $error (expected (error $errno)))
  )

  ;;; Force the allocation of space in a file.
  ;;; Note: This is similar to `posix_fallocate` in POSIX.
  (@interface func (export "fd_allocate")
    (param $fd $fd)
    ;;; The offset at which to start the allocation.
    (param $offset $filesize)
    ;;; The length of the area that is allocated.
    (param $len $filesize)
    (result $error (expected (error $errno)))
  )

  ;;; Close a file descriptor.
  ;;; Note: This is similar to `close` in POSIX.
  (@interface func (export "fd_close")
    (param $fd $fd)
    (result $error (expected (error $errno)))
  )

  ;;; Synchronize the data of a file to disk.
  ;;; Note: This is similar to `fdatasync` in POSIX.
  (@interface func (export "fd_datasync")
    (param $fd $fd)
    (result $error (expected (error $errno)))
  )

  ;;; Get the attributes of a file descriptor.
  ;;; Note: This returns similar flags to `fsync(fd, F_GETFL)` in POSIX, as well as additional fields.
  (@interface func (export "fd_fdstat_get")
    (param $fd $fd)
    ;;; The buffer where the file descriptor's attributes are stored.
    (result $error (expected $fdstat (error $errno)))
  )

  ;;; Adjust the flags associated with a file descriptor.
  ;;; Note: This is similar to `fcntl(fd, F_SETFL, flags)` in POSIX.
  (@interface func (export "fd_fdstat_set_flags")
    (param $fd $fd)
    ;;; The desired values of the file descriptor flags.
    (param $flags $fdflags)
    (result $error (expected (error $errno)))
  )

  ;;; Adjust the rights associated with a file descriptor.
  ;;; This can only be used to remove rights, and returns `errno::notcapable` if called in a way that would attempt to add rights
  (@interface func (export "fd_fdstat_set_rights")
    (param $fd $fd)
    ;;; The desired rights of the file descriptor.
    (param $fs_rights_base $rights)
    (param $fs_rights_inheriting $rights)
    (result $error (expected (error $errno)))
  )

  ;;; Return the attributes of an open file.
  (@interface func (export "fd_filestat_get")
    (param $fd $fd)
    ;;; The buffer where the file's attributes are stored.
    (result $error (expected $filestat (error $errno)))
  )

  ;;; Adjust the size of an open file. If this increases the file's size, the extra bytes are filled with zeros.
  ;;; Note: This is similar to `ftruncate` in POSIX.
  (@interface func (export "fd_filestat_set_size")
    (param $fd $fd)
    ;;; The desired file size.
    (param $size $filesize)
    (result $error (expected (error $errno)))
  )

  ;;; Adjust the timestamps of an open file or directory.
  ;;; Note: This is similar to `futimens` in POSIX.
  (@interface func (export "fd_filestat_set_times")
    (param $fd $fd)
    ;;; The desired values of the data access timestamp.
    (param $atim $timestamp)
    ;;; The desired values of the data modification timestamp.
    (param $mtim $timestamp)
    ;;; A bitmask indicating which timestamps to adjust.
    (param $fst_flags $fstflags)
    (result $error (expected (error $errno)))
  )

  ;;; Read from a file descriptor, without using and updating the file descriptor's offset.
  ;;; Note: This is similar to `preadv` in POSIX.
  (@interface func (export "fd_pread")
    (param $fd $fd)
    ;;; List of scatter/gather vectors in which to store data.
    (param $iovs $iovec_array)
    ;;; The offset within the file at which to read.
    (param $offset $filesize)
    ;;; The number of bytes read.
    (result $error (expected $size (error $errno)))
  )

  ;;; Return a description of the given preopened file descriptor.
  (@interface func (export "fd_prestat_get")
    (param $fd $fd)
    ;;; The buffer where the description is stored.
    (result $error (expected $prestat (error $errno)))
  )

  ;;; Return a description of the given preopened file descriptor.
  (@interface func (export "fd_prestat_dir_name")
    (param $fd $fd)
    ;;; A buffer into which to write the preopened directory name.
    (param $path (@witx pointer u8))
    (param $path_len $pointersize)
    (result $error (expected (error $errno)))
  )

  ;;; Write to a file descriptor, without using and updating the file descriptor's offset.
  ;;; Note: This is similar to `pwritev` in POSIX.
  (@interface func (export "fd_pwrite")
    (param $fd $fd)
    ;;; List of scatter/gather vectors from which to retrieve data.
    (param $iovs $ciovec_array)
    ;;; The offset within the file at which to write.
    (param $offset $filesize)
    ;;; The number of bytes written.
    (result $error (expected $size (error $errno)))
  )

  ;;; Read from a file descriptor.
  ;;; Note: This is similar to `readv` in POSIX.
  (@interface func (export "fd_read")
    (param $fd $fd)
    ;;; List of scatter/gather vectors to which to store data.
    (param $iovs $iovec_array)
    ;;; The number of bytes read.
    (result $error (expected $size (error $errno)))
  )

  ;;; Read directory entries from a directory.
  ;;; When successful, the contents of the output buffer consist of a sequence of
  ;;; directory entries. Each directory entry consists of a `dirent` object,
  ;;; followed by `dirent::d_namlen` bytes holding the name of the directory
  ;;; entry.
  ;;
  ;;; This function fills the output buffer as much as possible, potentially
  ;;; truncating the last directory entry. This allows the caller to grow its
  ;;; read buffer size in case it's too small to fit a single large directory
  ;;; entry, or skip the oversized directory entry.
  (@interface func (export "fd_readdir")
    (param $fd $fd)
    ;;; The buffer where directory entries are stored
    (param $buf (@witx pointer u8))
    (param $buf_len $pointersize)
    ;;; The location within the directory to start reading
    (param $cookie $dircookie)
    ;;; The number of bytes stored in the read buffer. If less than the size of the read buffer, the end of the directory has been reached.
    (result $error (expected $size (error $errno)))
  )

  ;;; Atomically replace a file descriptor by renumbering another file descriptor.
  ;;
  ;;; Due to the strong focus on thread safety, this environment does not provide
  ;;; a mechanism to duplicate or renumber a file descriptor to an arbitrary
  ;;; number, like `dup2()`. This would be prone to race conditions, as an actual
  ;;; file descriptor with the same number could be allocated by a different
  ;;; thread at the same time.
  ;;
  ;;; This function provides a way to atomically renumber file descriptors, which
  ;;; would disappear if `dup2()` were to be removed entirely.
  (@interface func (export "fd_renumber")
    (param $fd $fd)
    ;;; The file descriptor to overwrite.
    (param $to $fd)
    (result $error (expected (error $errno)))
  )

  ;;; Atomically duplicate a file handle.
  ;;
  (@interface func (export "fd_dup")
    (param $fd $fd)
    (result $error (expected $fd (error $errno)))
  )

  ;;; Creates a file handle for event notifications
  ;;;
  (@interface func (export "fd_event")
    (param $initial_val u64)
    (param $flags $eventfdflags)
    (result $error (expected $fd (error $errno)))
  )

  ;;; Move the offset of a file descriptor.
  ;;; Note: This is similar to `lseek` in POSIX.
  (@interface func (export "fd_seek")
    (param $fd $fd)
    ;;; The number of bytes to move.
    (param $offset $filedelta)
    ;;; The base from which the offset is relative.
    (param $whence $whence)
    ;;; The new offset of the file descriptor, relative to the start of the file.
    (result $error (expected $filesize (error $errno)))
  )

  ;;; Synchronize the data and metadata of a file to disk.
  ;;; Note: This is similar to `fsync` in POSIX.
  (@interface func (export "fd_sync")
    (param $fd $fd)
    (result $error (expected (error $errno)))
  )

  ;;; Return the current offset of a file descriptor.
  ;;; Note: This is similar to `lseek(fd, 0, SEEK_CUR)` in POSIX.
  (@interface func (export "fd_tell")
    (param $fd $fd)
    ;;; The current offset of the file descriptor, relative to the start of the file.
    (result $error (expected $filesize (error $errno)))
  )

  ;;; Write to a file descriptor.
  ;;; Note: This is similar to `writev` in POSIX.
  (@interface func (export "fd_write")
    (param $fd $fd)
    ;;; List of scatter/gather vectors from which to retrieve data.
    (param $iovs $ciovec_array)
    (result $error (expected $size (error $errno)))
  )

  ;;; Opens a pipe with two file handles
  ;;;
  ;;; Pipes are bidirectional
  (@interface func (export "fd_pipe")
    (result $error (expected (tuple $fd $fd) (error $errno)))
  )

  ;;; Create a directory.
  ;;; Note: This is similar to `mkdirat` in POSIX.
  (@interface func (export "path_create_directory")
    (param $fd $fd)
    ;;; The path at which to create the directory.
    (param $path string)
    (result $error (expected (error $errno)))
  )

  ;;; Return the attributes of a file or directory.
  ;;; Note: This is similar to `stat` in POSIX.
  (@interface func (export "path_filestat_get")
    (param $fd $fd)
    ;;; Flags determining the method of how the path is resolved.
    (param $flags $lookupflags)
    ;;; The path of the file or directory to inspect.
    (param $path string)
    ;;; The buffer where the file's attributes are stored.
    (result $error (expected $filestat (error $errno)))
  )

  ;;; Adjust the timestamps of a file or directory.
  ;;; Note: This is similar to `utimensat` in POSIX.
  (@interface func (export "path_filestat_set_times")
    (param $fd $fd)
    ;;; Flags determining the method of how the path is resolved.
    (param $flags $lookupflags)
    ;;; The path of the file or directory to operate on.
    (param $path string)
    ;;; The desired values of the data access timestamp.
    (param $atim $timestamp)
    ;;; The desired values of the data modification timestamp.
    (param $mtim $timestamp)
    ;;; A bitmask indicating which timestamps to adjust.
    (param $fst_flags $fstflags)
    (result $error (expected (error $errno)))
  )

  ;;; Create a hard link.
  ;;; Note: This is similar to `linkat` in POSIX.
  (@interface func (export "path_link")
    (param $old_fd $fd)
    ;;; Flags determining the method of how the path is resolved.
    (param $old_flags $lookupflags)
    ;;; The source path from which to link.
    (param $old_path string)
    ;;; The working directory at which the resolution of the new path starts.
    (param $new_fd $fd)
    ;;; The destination path at which to create the hard link.
    (param $new_path string)
    (result $error (expected (error $errno)))
  )

  ;;; Open a file or directory.
  ;;
  ;;; The returned file descriptor is not guaranteed to be the lowest-numbered
  ;;; file descriptor not currently open; it is randomized to prevent
  ;;; applications from depending on making assumptions about indexes, since this
  ;;; is error-prone in multi-threaded contexts. The returned file descriptor is
  ;;; guaranteed to be less than 2**31.
  ;;
  ;;; Note: This is similar to `openat` in POSIX.
  (@interface func (export "path_open")
    (param $fd $fd)
    ;;; Flags determining the method of how the path is resolved.
    (param $dirflags $lookupflags)
    ;;; The relative path of the file or directory to open, relative to the
    ;;; `path_open::fd` directory.
    (param $path string)
    ;;; The method by which to open the file.
    (param $oflags $oflags)
    ;;; The initial rights of the newly created file descriptor. The
    ;;; implementation is allowed to return a file descriptor with fewer rights
    ;;; than specified, if and only if those rights do not apply to the type of
    ;;; file being opened.
    ;;
    ;;; The *base* rights are rights that will apply to operations using the file
    ;;; descriptor itself, while the *inheriting* rights are rights that apply to
    ;;; file descriptors derived from it.
    (param $fs_rights_base $rights)
    (param $fs_rights_inheriting $rights)
    (param $fdflags $fdflags)
    ;;; The file descriptor of the file that has been opened.
    (result $error (expected $fd (error $errno)))
  )

  ;;; Read the contents of a symbolic link.
  ;;; Note: This is similar to `readlinkat` in POSIX.
  (@interface func (export "path_readlink")
    (param $fd $fd)
    ;;; The path of the symbolic link from which to read.
    (param $path string)
    ;;; The buffer to which to write the contents of the symbolic link.
    (param $buf (@witx pointer u8))
    (param $buf_len $pointersize)
    ;;; The number of bytes placed in the buffer.
    (result $error (expected $size (error $errno)))
  )

  ;;; Remove a directory.
  ;;; Return `errno::notempty` if the directory is not empty.
  ;;; Note: This is similar to `unlinkat(fd, path, AT_REMOVEDIR)` in POSIX.
  (@interface func (export "path_remove_directory")
    (param $fd $fd)
    ;;; The path to a directory to remove.
    (param $path string)
    (result $error (expected (error $errno)))
  )

  ;;; Rename a file or directory.
  ;;; Note: This is similar to `renameat` in POSIX.
  (@interface func (export "path_rename")
    (param $fd $fd)
    ;;; The source path of the file or directory to rename.
    (param $old_path string)
    ;;; The working directory at which the resolution of the new path starts.
    (param $new_fd $fd)
    ;;; The destination path to which to rename the file or directory.
    (param $new_path string)
    (result $error (expected (error $errno)))
  )

  ;;; Create a symbolic link.
  ;;; Note: This is similar to `symlinkat` in POSIX.
  (@interface func (export "path_symlink")
    ;;; The contents of the symbolic link.
    (param $old_path string)
    (param $fd $fd)
    ;;; The destination path at which to create the symbolic link.
    (param $new_path string)
    (result $error (expected (error $errno)))
  )


  ;;; Unlink a file.
  ;;; Return `errno::isdir` if the path refers to a directory.
  ;;; Note: This is similar to `unlinkat(fd, path, 0)` in POSIX.
  (@interface func (export "path_unlink_file")
    (param $fd $fd)
    ;;; The path to a file to unlink.
    (param $path string)
    (result $error (expected (error $errno)))
  )

  ;;; Concurrently poll for the occurrence of a set of events.
  (@interface func (export "poll_oneoff")
    ;;; The events to which to subscribe.
    (param $in (@witx const_pointer $subscription))
    ;;; The events that have occurred.
    (param $out (@witx pointer $event))
    ;;; Both the number of subscriptions and events.
    (param $nsubscriptions $size)
    ;;; The number of events stored.
    (result $error (expected $size (error $errno)))
  )

  ;;; Temporarily yield execution of the calling thread.
  ;;; Note: This is similar to `sched_yield` in POSIX.
  (@interface func (export "sched_yield")
    (result $error (expected (error $errno)))
  )

  ;;; Write high-quality random data into a buffer.
  ;;; This function blocks when the implementation is unable to immediately
  ;;; provide sufficient high-quality random data.
  ;;; This function may execute slowly, so when large mounts of random data are
  ;;; required, it's advisable to use this function to seed a pseudo-random
  ;;; number generator, rather than to provide the random data directly.
  (@interface func (export "random_get")
    ;;; The buffer to fill with random data.
    (param $buf (@witx pointer u8))
    (param $buf_len $pointersize)
    (result $error (expected (error $errno)))
  )

  ;;; Retrieves the current state of the TTY
  (@interface func (export "tty_get")
    (param $state (@witx pointer $tty))
    (result $error (expected (error $errno)))
  )

  ;;; Updates the properties of the rect
  (@interface func (export "tty_set")
    (param $state (@witx pointer $tty))
    (result $error (expected (error $errno)))
  )

  ;;; Returns the current working directory
  ;;; If the path exceeds the size of the buffer then this function
  ;;; will fill the path_len with the needed size and return EOVERFLOW
  (@interface func (export "getcwd")
    ;;; The buffer where current directory is stored
    (param $path (@witx pointer u8))
    (param $path_len (@witx pointer $pointersize))
    (result $error (expected (error $errno)))
  )

  ;;; Sets the current working directory
  (@interface func (export "chdir")
    ;;; Path to change the current working directory to
    (param $path string)
    (result $error (expected (error $errno)))
  )

  ;;; Registers a callback function for signals
  (@interface func (export "callback_signal")
    ;;; Exported function that will be called back when the signal triggers
    ;;; (must match the callback signature that takes the signal value)
    ;;; (if this is not specified the default will be "_signal")
    (param $callback string)
  )

  ;;; Registers a callback function for new threads
  (@interface func (export "callback_thread")
    ;;; Exported function that will be called back when a new thread is created
    ;;; (must match the callback signature that takes the u64 user_data)
    ;;; (if this is not specified the default will be "_start_thread")
    (param $callback string)
  )

  ;;; Registers a callback function for reactors
  (@interface func (export "callback_reactor")
    ;;; Exported function that will be called back when the reactor is triggered
    ;;; (must match the callback signature that takes the u64 user_data)
    ;;; (if this is not specified the default will be "_reactor")
    (param $callback string)
  )

  ;;; Registers a callback function for destruction of thread locals
  (@interface func (export "callback_thread_local_destroy")
    ;;; Exported function that will be called back when the reactor is triggered
    ;;; (must match the callback signature that takes the u64 user_data)
    ;;; (if this is not specified the default will be "_thread_local_destroy")
    (param $callback string)
  )

  ;;; Creates a new thread by spawning that shares the same
  ;;; memory address space, file handles and main event loops.
  ;;; The web assembly process must export function named '_start_thread'
  (@interface func (export "thread_spawn")
    ;;; User data that will be supplied to the function when its called
    (param $user_data u64)
    ;;; The base address of the stack allocated for this thread
    (param $stack_base u64)
    ;;; The start address of the stack (where the memory is allocated)
    (param $stack_start u64)
    ;;; Indicates if the function will operate as a reactor or
    ;;; as a normal thread. Reactors will be repeatable called
    ;;; whenever IO work is available to be processed.
    (param $reactor $bool)
    ;;; Returns the thread index of the newly created thread
    ;;; (indices always start from zero)
    (result $error (expected $tid (error $errno)))
  )

  ;;; Sends the current thread to sleep for a period of time
  (@interface func (export "thread_sleep")
    ;;; Amount of time that the thread should sleep
    (param $duration $timestamp)
    (result $error (expected (error $errno)))
  )

  ;;; Returns the index of the current thread
  ;;; (threads indices are sequencial from zero)
  (@interface func (export "thread_id")
    (result $error (expected $tid (error $errno)))
  )

  ;;; Create a thread local variable
  ;;; If The web assembly process exports function named '_thread_local_destroy'
  ;;; then it will be invoked when the thread goes out of scope and dies.
  (@interface func (export "thread_local_create")
    ;;; User data that will be passed to the destructor
    ;;; when the thread variable goes out of scope
    (param $user_data u64)
    (result $error (expected $tl_key (error $errno)))
  )

  ;;; Destroys a thread local variable
  (@interface func (export "thread_local_destroy")
    ;;; Thread key that was previously created
    (param $key $tl_key)
    (result $error (expected (error $errno)))
  )

  ;;; Sets the value of a thread local variable
  (@interface func (export "thread_local_set")
    ;;; Thread key that this local variable will be associated with
    (param $key $tl_key)
    ;;; Value to be set for the thread local variable
    (param $val $tl_val)
    (result $error (expected (error $errno)))
  )

  ;;; Gets the value of a thread local variable
  (@interface func (export "thread_local_get")
    ;;; Thread key that this local variable that was previous set
    (param $key $tl_key)
    (result $error (expected $tl_val (error $errno)))
  )

  ;;; Joins this thread with another thread, blocking this
  ;;; one until the other finishes
  (@interface func (export "thread_join")
    ;;; Handle of the thread to wait on
    (param $tid $tid)
    (result $error (expected (error $errno)))
  )

  ;;; Returns the available parallelism which is normally the
  ;;; number of available cores that can run concurrently
  (@interface func (export "thread_parallelism")
    (result $error (expected $size (error $errno)))
  )

  ;;; Sends a signal to a thread
  (@interface func (export "thread_signal")
    ;;; Handle of the thread to send a singal
    (param $tid $tid)
    ;;; Signal to send to the thread
    (param $signal $signal)
    (result $error (expected (error $errno)))
  )

  ;;; Wait for a futex_wake operation to wake us.
  ;;; Returns with EINVAL if the futex doesn't hold the expected value.
  ;;; Returns false on timeout, and true in all other cases.
  (@interface func (export "futex_wait")
    ;;; Memory location that holds the value that will be checked
    (param $futex (@witx pointer u32))
    ;;; Expected value that should be currently held at the memory location
    (param $expected u32)
    ;;; Timeout should the futex not be triggered in the allocated time
    (param $timeout (@witx const_pointer $option_timestamp))
    (result $error (expected $bool (error $errno)))
  )

  ;;; Wake up one thread that's blocked on futex_wait on this futex.
  ;;; Returns true if this actually woke up such a thread,
  ;;; or false if no thread was waiting on this futex.
  (@interface func (export "futex_wake")
    ;;; Memory location that holds a futex that others may be waiting on
    (param $futex (@witx pointer u32))
    (result $error (expected $bool (error $errno)))
  )

  ;;; Wake up all threads that are waiting on futex_wait on this futex.
  (@interface func (export "futex_wake_all")
    ;;; Memory location that holds a futex that others may be waiting on
    (param $futex (@witx pointer u32))
    (result $error (expected $bool (error $errno)))
  )

  ;;; Terminates the current running thread, if this is the last thread then
  ;;; the process will also exit with the specified exit code. An exit code
  ;;; of 0 indicates successful termination of the thread. The meanings of
  ;;; other values is dependent on the environment.
  (@interface func (export "thread_exit")
    ;;; The exit code returned by the process.
    (param $rval $exitcode)
    (@witx noreturn)
  )

  ;;; Creates a checkpoint of the current stack which allows it to be restored
  ;;; later using its stack hash. The value supplied will be returned upon
  ;;; restoration (and hence must be none zero) - zero will be returned when
  ;;; the stack is first recorded.
  ;;; This function will read the __stack_pointer global
  (@interface func (export "stack_checkpoint")
    ;;; Reference to the stack snapshot that will be filled
    (param $snapshot (@witx pointer $stack_snapshot))
    ;;; Returns zero upon registration and the value when restored
    (result $error (expected $longsize (error $errno)))
  )

  ;;; Restores the current stack to a previous stack described by a supplied
  ;;; stack snapshot.
  ;;; This function will manipulate the __stack_pointer global
  (@interface func (export "stack_restore")
    ;;; Reference to the stack snapshot that will be restored
    (param $snapshot (@witx const_pointer $stack_snapshot))
    ;;; Value to be returned when the stack is restored
    ;;; (if zero this will change to one)
    (param $val $longsize)
    ;;; This function never returns
    (@witx noreturn)
  )

  ;;; Terminate the process normally. An exit code of 0 indicates successful
  ;;; termination of the program. The meanings of other values is dependent on
  ;;; the environment.
  (@interface func (export "proc_exit")
    ;;; The exit code returned by the process.
    (param $rval $exitcode)
    (@witx noreturn)
  )

  ;;; Send a signal to the process of the calling thread.
  ;;; Note: This is similar to `raise` in POSIX.
  (@interface func (export "proc_raise")
    ;;; The signal condition to trigger.
    (param $sig $signal)
    (result $error (expected (error $errno)))
  )

  ;;; Send a signal to the process of the calling thread on a regular basis
  ;;; Note: This is similar to `setitimer` in POSIX.
  (@interface func (export "proc_raise_interval")
    ;;; The signal condition to trigger.
    (param $sig $signal)
    ;;; Time to wait before raising the signal
    ;;; (zero here indicates the signal interval is cancelled)
    (param $interval $timestamp)
    ;;; Flag that indicates if the signal will trigger indefinately
    (param $repeat $bool)
    (result $error (expected (error $errno)))
  )

  ;;; Forks the current process into a new subprocess. If the function
  ;;; returns a zero then its the new subprocess. If it returns a positive
  ;;; number then its the current process and the $pid represents the child.
  (@interface func (export "proc_fork")
    ;;; Indicates if the memory will be copied into the new process
    ;;; (if it is not copied this then becomes similar to `vfork` in
    ;;;  that the current process pauses until `proc_exec` is called)
    (param $copy_memory $bool)
    (result $error (expected $pid (error $errno)))
  )

  ;;; execve()  executes  the  program  referred to by pathname.  This causes the
  ;;; program that is currently being run by the calling process to  be  replaced
  ;;; with  a  new  program, with newly initialized stack, heap, and (initialized
  ;;; and uninitialized) data segments
  ;;;
  ;;; If the named process does not exist then the process will fail and terminate
  (@interface func (export "proc_exec")
    ;;; Name of the process to be spawned
    (param $name string)
    ;;; List of the arguments to pass the process
    ;;; (entries are separated by line feeds)
    (param $args string)
    ;;; This function never returns
    (@witx noreturn)
  )

  ;;; Spawns a new process within the context of this machine
  (@interface func (export "proc_spawn")
    ;;; Name of the process to be spawned
    (param $name string)
    ;;; Indicates if the process will chroot or not
    (param $chroot $bool)
    ;;; List of the arguments to pass the process
    ;;; (entries are separated by line feeds)
    (param $args string)
    ;;; List of the preopens for this process
    ;;; (entries are separated by line feeds)
    (param $preopen string)
    ;;; How will stdin be handled
    (param $stdin $stdio_mode)
    ;;; How will stdout be handled
    (param $stdout $stdio_mode)
    ;;; How will stderr be handled
    (param $stderr $stdio_mode)
    ;;; Working directory where this process should run
    ;;; (passing '.' will use the current directory)
    (param $working_dir string)
    ;;; Returns a bus process id that can be used to invoke calls
    (result $error (expected $process_handles (error $bus_error)))
  )

  ;;; Returns the handle of the current process
  (@interface func (export "proc_id")
    (result $error (expected $pid (error $errno)))
  )

  ;;; Returns the parent handle of a particular process
  (@interface func (export "proc_parent")
    ;;; Handle of the process to get the parent handle for
    (param $pid $pid)
    (result $error (expected $pid (error $errno)))
  )

  ;;; Wait for process to exit
  (@interface func (export "proc_join")
    ;;; ID of the process to wait on
    (param $pid (@witx pointer $option_pid))
    ;;; Flags that determine how the join behaves
    (param $flags $join_flags)
    ;;; Returns the status of the process
    (result $error (expected $join_status_type (error $errno)))
  )

  ;;; Sends a signal to a process
  (@interface func (export "proc_signal")
    ;;; ID of the process to send a singal
    (param $pid $pid)
    ;;; Signal to send to the thread
    (param $signal $signal)
    (result $error (expected (error $errno)))
  )

  ;;; Spawns a new bus process for a particular web WebAssembly
  ;;; binary that is referenced by its process name.
  (@interface func (export "bus_open_local")
    ;;; Name of the process to be spawned
    (param $name string)
    ;;; Indicates if the existing processes should be reused
    ;;; if they are already running
    (param $reuse $bool)
    ;;; Returns a bus process id that can be used to invoke calls
    (result $error (expected $bid (error $bus_error)))
  )

  ;;; Spawns a new bus process for a particular web WebAssembly
  ;;; binary that is referenced by its process name on a remote instance.
  (@interface func (export "bus_open_remote")
    ;;; Name of the process to be spawned
    (param $name string)
    ;;; Indicates if the existing processes should be reused
    ;;; if they are already running
    (param $reuse $bool)
    ;;; Instance identifier where this process will be spawned
    (param $instance string)
    ;;; Acceess token used to authenticate with the instance
    (param $token string)
    ;;; Returns a bus process id that can be used to invoke calls
    (result $error (expected $bid (error $bus_error)))
  )

  ;;; Closes a bus process and releases all associated resources
  (@interface func (export "bus_close")
    ;;; Handle of the bus process handle to be closed
    (param $bid $bid)
    (result $error (expected (error $bus_error)))
  )

  ;;; Invokes a call within a running bus process.
  (@interface func (export "bus_call")
    ;;; Handle of the bus process to invoke the call within
    (param $bid $bid)
    ;;; Topic hash that describes the type of call to made
    (param $topic_hash (@witx const_pointer $hash))
    ;;; Format of the data pushed onto the bus
    (param $format $bus_data_format)
    ;;; The buffer where data to be transmitted is stored
    (param $buf $buf_array)
    (result $error (expected $cid (error $bus_error)))
  )

  ;;; Invokes a call within the context of another call
  (@interface func (export "bus_subcall")
    ;;; Parent bus call that this is related to
    (param $parent $cid)
    ;;; Topic hash that describes the type of call to made
    (param $topic_hash (@witx const_pointer $hash))
    ;;; Format of the data pushed onto the bus
    (param $format $bus_data_format)
    ;;; The buffer where data to be transmitted is stored
    (param $buf $buf_array)
    (result $error (expected $cid (error $bus_error)))
  )

  ;;; Polls for any outstanding events from a particular
  ;;; bus process by its handle
  (@interface func (export "bus_poll")
    ;;; Timeout before the poll returns, if one passed 0
    ;;; as the timeout then this call is non blocking.
    (param $timeout $timestamp)
    ;;; An events buffer that will hold any received bus events
    (param $events (@witx pointer $bus_event))
    (param $nevents $size)
    ;;; Returns the number of events that have occured
    (result $error (expected $size (error $bus_error)))
  )

  ;;; Replies to a call that was made to this process
  ;;; from another process; where 'cid' is the call context.
  ;;; This will may also drop the handle and release any
  ;;; associated resources (if keepalive is not set)
  (@interface func (export "call_reply")
    ;;; Handle of the call to send a reply on
    (param $cid $cid)
    ;;; Format of the data pushed onto the bus
    (param $format $bus_data_format)
    ;;; The buffer where data to be transmitted is stored
    (param $buf $buf_array)
    (result $error (expected (error $bus_error)))
  )

  ;;; Causes a fault on a particular call that was made
  ;;; to this process from another process; where 'bid'
  ;;; is the callering process context.
  (@interface func (export "call_fault")
    ;;; Handle of the call to raise a fault on
    (param $cid $cid)
    ;;; Fault to be raised on the bus
    (param $fault $bus_error)
  )

  ;;; Closes a bus call based on its bus call handle
  (@interface func (export "call_close")
    ;;; Handle of the bus call handle to be dropped
    (param $cid $cid)
  )

  ;;; Connects to a websocket at a particular network URL
  (@interface func (export "ws_connect")
    ;;; URL of the web socket destination to connect to
    (param $url string)
    ;;; Returns a socket handle which is used to send and receive data
    (result $error (expected $fd (error $errno)))
  )

  ;;; Makes a HTTP request to a remote web resource and
  ;;; returns a socket handles that are used to send and receive data
  (@interface func (export "http_request")
    ;;; URL of the HTTP resource to connect to
    (param $url string)
    ;;; HTTP method to be invoked
    (param $method string)
    ;;; HTTP headers to attach to the request
    ;;; (headers seperated by lines)
    (param $headers string)
    ;;; Should the request body be compressed
    (param $gzip $bool)
    ;;; The body of the response can be streamed from the returned
    ;;; file handle
    (result $error (expected $http_handles (error $errno)))
  )

  ;;; Retrieves the status of a HTTP request
  (@interface func (export "http_status")
    ;;; Handle of the HTTP request
    (param $fd $fd) 
    ;;; Pointer to a buffer that will be filled with the current
    ;;; status of this HTTP request
    (param $status (@witx pointer $http_status))
    (result $error (expected (error $errno)))
  )

  ;;; Securely connects to a particular remote network
  (@interface func (export "port_bridge")
    ;;; Fully qualified identifier for the network
    (param $network string)
    ;;; Access token used to authenticate with the network
    (param $token string)
    ;;; Level of encryption to encapsulate the network connection with
    (param $security $stream_security)
    (result $error (expected (error $errno)))
  )

  ;;; Disconnects from a remote network
  (@interface func (export "port_unbridge")
    (result $error (expected (error $errno)))
  )

  ;;; Acquires a set of addresses using DHCP
  (@interface func (export "port_dhcp_acquire")
    (result $error (expected (error $errno)))
  )

  ;;; Adds another static address to the local port
  (@interface func (export "port_addr_add")
    ;;; Address to be added
    (param $addr (@witx const_pointer $addr_cidr))
    (result $error (expected (error $errno)))
  )

  ;;; Removes an address from the local port
  (@interface func (export "port_addr_remove")
    ;;; Address to be removed
    (param $addr (@witx const_pointer $addr))
    (result $error (expected (error $errno)))
  )

  ;;; Clears all the addresses on the local port
  (@interface func (export "port_addr_clear")
    (result $error (expected (error $errno)))
  )

  ;;; Returns the MAC address of the local port
  (@interface func (export "port_mac")
    (result $error (expected $hardware_address (error $errno)))
  )

  ;;; Returns a list of all the addresses owned by the local port
  ;;; This function fills the output buffer as much as possible.
  ;;; If the buffer is not big enough then the naddrs address will be
  ;;; filled with the buffer size needed and the EOVERFLOW will be returned
  (@interface func (export "port_addr_list")
    ;;; The buffer where addresses will be stored
    (param $addrs (@witx pointer $addr_cidr))
    (param $naddrs (@witx pointer $size))
    ;;; The number of addresses returned.
    (result $error (expected (error $errno)))
  )

  ;;; Adds a default gateway to the port
  (@interface func (export "port_gateway_set")
    ;;; Address of the default gateway
    (param $addr (@witx const_pointer $addr))
    (result $error (expected (error $errno)))
  )

  ;;; Adds a new route to the local port
  (@interface func (export "port_route_add")
    (param $cidr (@witx const_pointer $addr_cidr))
    (param $via_router (@witx const_pointer $addr))
    (param $preferred_until (@witx const_pointer $option_timestamp))
    (param $expires_at (@witx const_pointer $option_timestamp))
    (result $error (expected (error $errno)))
  )

  ;;; Removes an existing route from the local port
  (@interface func (export "port_route_remove")
    (param $cidr (@witx const_pointer $addr))
    (result $error (expected (error $errno)))
  )

  ;;; Clears all the routes in the local port
  (@interface func (export "port_route_clear")
    (result $error (expected (error $errno)))
  )

  ;;; Returns a list of all the routes owned by the local port
  ;;; This function fills the output buffer as much as possible.
  ;;; If the buffer is too small this will return EOVERFLOW and
  ;;; fill nroutes with the size of the buffer needed.
  (@interface func (export "port_route_list")
    ;;; The buffer where routes will be stored
    (param $routes (@witx pointer $route))
    (param $nroutes (@witx pointer $size))
    (result $error (expected (error $errno)))
  )

  ;;; Shut down socket send and receive channels.
  ;;; Note: This is similar to `shutdown` in POSIX.
  (@interface func (export "sock_shutdown")
    (param $fd $fd)
    ;;; Which channels on the socket to shut down.
    (param $how $sdflags)
    (result $error (expected (error $errno)))
  )

  ;;; Returns the current status of a socket
  (@interface func (export "sock_status")
    (param $fd $fd)
    (result $error (expected $sock_status (error $errno)))
  )

  ;;; Returns the local address to which the socket is bound.
  ;;;
  ;;; Note: This is similar to `getsockname` in POSIX
  ;;;
  ;;; When successful, the contents of the output buffer consist of an IP address,
  ;;; either IP4 or IP6.
  (@interface func (export "sock_addr_local")
    ;;; Socket that the address is bound to
    (param $fd $fd)
    (result $error (expected $addr_port (error $errno)))
  )

  ;;; Returns the remote address to which the socket is connected to.
  ;;;
  ;;; Note: This is similar to `getpeername` in POSIX
  ;;;
  ;;; When successful, the contents of the output buffer consist of an IP address,
  ;;; either IP4 or IP6.
  (@interface func (export "sock_addr_peer")
    ;;; Socket that the address is bound to
    (param $fd $fd)
    (result $error (expected $addr_port (error $errno)))
  )

  ;;; Create an endpoint for communication.
  ;;;
  ;;; creates an endpoint for communication and returns a file descriptor
  ;;; tor that refers to that endpoint. The file descriptor returned by a successful
  ;;; call will be the lowest-numbered file descriptor not currently open
  ;;; for the process.
  ;;;
  ;;; Note: This is similar to `socket` in POSIX using PF_INET
  (@interface func (export "sock_open")
    ;;; Address family
    (param $af $address_family)
    ;;; Socket type, either datagram or stream
    (param $socktype $sock_type)
    ;;; Socket protocol
    (param $sock_proto $sock_proto)
    ;;; The file descriptor of the socket that has been opened.
    (result $error (expected $fd (error $errno)))
  )

  ;;; Sets a particular socket setting
  ;;; Note: This is similar to `setsockopt` in POSIX for SO_REUSEADDR
  (@interface func (export "sock_set_opt_flag")
    ;;; Socket descriptor
    (param $fd $fd)
    ;;; Socket option to be set
    (param $sockopt $sock_option)
    ;;; Value to set the option to
    (param $flag $bool)
    (result $error (expected (error $errno)))
  )

  ;;; Retrieve status of particular socket seting
  ;;; Note: This is similar to `getsockopt` in POSIX for SO_REUSEADDR
  (@interface func (export "sock_get_opt_flag")
    ;;; Socket descriptor
    (param $fd $fd)
    ;;; Socket option to be retrieved
    (param $sockopt $sock_option)
    (result $error (expected $bool (error $errno)))
  )

  ;;; Sets one of the times the socket
  (@interface func (export "sock_set_opt_time")
    ;;; Socket descriptor
    (param $fd $fd)
    ;;; Socket option to be set
    (param $sockopt $sock_option)
    ;;; Value to set the time to
    (param $timeout (@witx const_pointer $option_timestamp))
    (result $error (expected (error $errno)))
  )

  ;;; Retrieve one of the times on the socket
  (@interface func (export "sock_get_opt_time")
    ;;; Socket descriptor
    (param $fd $fd)
    ;;; Socket option to be retrieved
    (param $sockopt $sock_option)
    (result $error (expected $option_timestamp (error $errno)))
  )

  ;;; Set size of particular option for this socket
  ;;; Note: This is similar to `setsockopt` in POSIX for SO_RCVBUF
  (@interface func (export "sock_set_opt_size")
    ;;; Socket descriptor
    (param $fd $fd)
    ;;; Socket option to be set
    (param $sockopt $sock_option)
    ;;; Buffer size
    (param $size $filesize)
    (result $error (expected (error $errno)))
  )

  ;;; Retrieve the size of particular option for this socket
  ;;; Note: This is similar to `getsockopt` in POSIX for SO_RCVBUF
  (@interface func (export "sock_get_opt_size")
    ;;; Socket descriptor
    (param $fd $fd)
    ;;; Socket option to be retrieved
    (param $sockopt $sock_option)
    (result $error (expected $filesize (error $errno)))
  )

  ;;; Joins a particular multicast IPv4 group
  (@interface func (export "sock_join_multicast_v4")
    ;;; Socket descriptor
    (param $fd $fd)
    ;;; Multicast group to joined
    (param $multiaddr (@witx const_pointer $addr_ip4))
    ;;; Interface that will join
    (param $interface (@witx const_pointer $addr_ip4))
    (result $error (expected (error $errno)))
  )

  ;;; Leaves a particular multicast IPv4 group
  (@interface func (export "sock_leave_multicast_v4")
    ;;; Socket descriptor
    (param $fd $fd)
    ;;; Multicast group to leave
    (param $multiaddr (@witx const_pointer $addr_ip4))
    ;;; Interface that will left
    (param $interface (@witx const_pointer $addr_ip4))
    (result $error (expected (error $errno)))
  )

  ;;; Joins a particular multicast IPv6 group
  (@interface func (export "sock_join_multicast_v6")
    ;;; Socket descriptor
    (param $fd $fd)
    ;;; Multicast group to joined
    (param $multiaddr (@witx const_pointer $addr_ip6))
    ;;; Interface that will join
    (param $interface u32)
    (result $error (expected (error $errno)))
  )

  ;;; Leaves a particular multicast IPv6 group
  (@interface func (export "sock_leave_multicast_v6")
    ;;; Socket descriptor
    (param $fd $fd)
    ;;; Multicast group to leave
    (param $multiaddr (@witx const_pointer $addr_ip6))
    ;;; Interface that will left
    (param $interface u32)
    (result $error (expected (error $errno)))
  )

  ;;; Bind a socket
  ;;; Note: This is similar to `bind` in POSIX using PF_INET
  (@interface func (export "sock_bind")
    ;;; File descriptor of the socket to be bind
    (param $fd $fd)
    ;;; Address to bind the socket to
    (param $addr (@witx const_pointer $addr_port))
    (result $error (expected (error $errno)))
  )

  ;;; Listen for connections on a socket
  ;;;
  ;;; Polling the socket handle will wait until a connection
  ;;; attempt is made
  ;;;
  ;;; Note: This is similar to `listen`
  (@interface func (export "sock_listen")
    ;;; File descriptor of the socket to be bind
    (param $fd $fd)
    ;;; Maximum size of the queue for pending connections
    (param $backlog $size)
    (result $error (expected (error $errno)))
  )
  
  ;;; Accept a new incoming connection.
  ;;; Note: This is similar to `accept` in POSIX.
  (@interface func (export "sock_accept")
    ;;; The listening socket.
    (param $fd $fd)
    ;;; The desired values of the file descriptor flags.
    (param $flags $fdflags)
    ;;; New socket connection
    (result $error (expected (tuple $fd $addr_port) (error $errno)))
  )

  ;;; Initiate a connection on a socket to the specified address
  ;;; 
  ;;; Polling the socket handle will wait for data to arrive or for
  ;;; the socket status to change which can be queried via 'sock_status'
  ;;;
  ;;; Note: This is similar to `connect` in POSIX
  (@interface func (export "sock_connect")
    ;;; Socket descriptor
    (param $fd $fd)
    ;;; Address of the socket to connect to
    (param $addr (@witx const_pointer $addr_port))
    (result $error (expected (error $errno)))
  )

  ;;; Receive a message from a socket.
  ;;; Note: This is similar to `recv` in POSIX, though it also supports reading
  ;;; the data into multiple buffers in the manner of `readv`.
  (@interface func (export "sock_recv")
    (param $fd $fd)
    ;;; List of scatter/gather vectors to which to store data.
    (param $ri_data $iovec_array)
    ;;; Message flags.
    (param $ri_flags $riflags)
    ;;; Number of bytes stored in ri_data and message flags.
    (result $error (expected (tuple $size $roflags) (error $errno)))
  )

  ;;; Receive a message and its peer address from a socket.
  ;;; Note: This is similar to `recvfrom` in POSIX, though it also supports reading
  ;;; the data into multiple buffers in the manner of `readv`.
  (@interface func (export "sock_recv_from")
    (param $fd $fd)
    ;;; List of scatter/gather vectors to which to store data.
    (param $ri_data $iovec_array)
    ;;; Message flags.
    (param $ri_flags $riflags)
    ;;; Number of bytes stored in ri_data and message flags.
    (result $error (expected (tuple $size $roflags $addr_port) (error $errno)))
  )

  ;;; Send a message on a socket.
  ;;; Note: This is similar to `send` in POSIX, though it also supports writing
  ;;; the data from multiple buffers in the manner of `writev`.
  (@interface func (export "sock_send")
    (param $fd $fd)
    ;;; List of scatter/gather vectors to which to retrieve data
    (param $si_data $ciovec_array)
    ;;; Message flags.
    (param $si_flags $siflags)
    ;;; Number of bytes transmitted.
    (result $error (expected $size (error $errno)))
  )

  ;;; Send a message on a socket to a specific address.
  ;;; Note: This is similar to `sendto` in POSIX, though it also supports writing
  ;;; the data from multiple buffers in the manner of `writev`.
  (@interface func (export "sock_send_to")
    (param $fd $fd)
    ;;; List of scatter/gather vectors to which to retrieve data
    (param $si_data $ciovec_array)
    ;;; Message flags.
    (param $si_flags $siflags)
    ;;; Address of the socket to send message to
    (param $addr (@witx const_pointer $addr_port))
    ;;; Number of bytes transmitted.
    (result $error (expected $size (error $errno)))
  )

  ;;; Sends the entire contents of a file down a socket
  (@interface func (export "sock_send_file")
    (param $out_fd $fd)
    ;;; Open file that has the data to be transmitted
    (param $in_fd $fd)
    ;;; Offset into the file to start reading at
    (param $offset $filesize)
    ;;; Number of bytes to be sent
    (param $count $filesize)
    ;;; Number of bytes transmitted.
    (result $error (expected $filesize (error $errno)))
  )

  ;;; Resolves a hostname and a port to one or more IP addresses.
  ;;;
  ;;; Note: This is similar to `getaddrinfo` in POSIX
  ;;;
  ;;; When successful, the contents of the output buffer consist of a sequence of
  ;;; IPv4 and/or IPv6 addresses. Each address entry consists of a addr_t object.
  ;;
  ;;; This function fills the output buffer as much as possible.
  (@interface func (export "resolve")
    ;;; Host to resolve
    (param $host string)
    ;;; Port hint (zero if no hint is supplied)
    (param $port u16)
    ;;; The buffer where addresses will be stored
    (param $addrs (@witx pointer $addr))
    (param $naddrs $size)
    ;;; The number of IP addresses returned during the DNS resolution.
    (result $error (expected $size (error $errno)))
  )
)
