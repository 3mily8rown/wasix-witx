;; WASI Sockets.
;;
;; Some content here is derived from [CloudABI](https://github.com/NuxiNL/cloudabi).
;;
;; This is a `witx` file. See [here](https://github.com/WebAssembly/WASI/tree/master/docs/witx.md)
;; for an explanation of what that means.

(use "typenames.witx")

(module $wasi_ephemeral_sock
  ;;; Linear memory to be accessed by WASI functions that need it.
  (import "memory" (memory))

  ;;; Connects to a websocket at a particular network URL
  (@interface func (export "ws_connect")
    ;;; URL of the web socket destination to connect to
    (param $url string)
    ;;; Returns a socket handle which is used to send and receive data
    (result $error (expected $fd (error $errno)))
  )

  ;;; Makes a HTTP request to a remote web resource and
  ;;; returns a socket handles that are used to send and receive data
  (@interface func (export "http_request")
    ;;; URL of the HTTP resource to connect to
    (param $url string)
    ;;; HTTP method to be invoked
    (param $method string)
    ;;; HTTP headers to attach to the request
    ;;; (headers seperated by lines)
    (param $headers string)
    ;;; Should the request body be compressed
    (param $gzip $bool)
    ;;; The body of the response can be streamed from the returned
    ;;; file handle
    (result $error (expected $http_handles (error $errno)))
  )

  ;;; Retrieves the status of a HTTP request
  (@interface func (export "http_status")
    ;;; Handle of the HTTP request
    (param $fd $fd) 
    ;;; Pointer to a buffer that will be filled with the current
    ;;; status of this HTTP request
    (param $status (@witx pointer $http_status))
    ;;; Buffer that will hold the status text
    (param $status_text (@witx pointer u8))
    ;;; This field will also be filled with the number of bytes returned in the status text
    (param $status_text_len (@witx pointer $pointersize))
    ;;; Buffer that will hold the response headers
    (param $headers (@witx pointer u8))
    ;;; This field will also be filled with the number of bytes returned in the response headers
    (param $headers_len (@witx pointer $pointersize))
    (result $error (expected (error $errno)))
  )

  ;;; Securely connects to a particular remote network
  (@interface func (export "bridge")
    ;;; Fully qualified identifier for the network
    (param $network string)
    ;;; Access token used to authenticate with the network
    (param $token string)
    ;;; Level of encryption to encapsulate the network connection with
    (param $security $stream_security)
    (result $error (expected (error $errno)))
  )

  ;;; Disconnects from a remote network
  (@interface func (export "unbridge")
    (result $error (expected (error $errno)))
  )

  ;;; Acquires a set of IP addresses using DHCP
  (@interface func (export "dhcp_acquire")
    (result $error (expected (error $errno)))
  )

  ;;; Adds another static IP address to the local port
  (@interface func (export "ip_add")
    ;;; IP address to be added
    (param $ip $addr_cidr)
    (result $error (expected (error $errno)))
  )

  ;;; Removes an IP address from the local port
  (@interface func (export "ip_remove")
    ;;; IP address to be removed
    (param $ip $addr_ip)
    (result $error (expected (error $errno)))
  )

  ;;; Clears all the IP addresses on the local port
  (@interface func (export "ip_clear")
    (result $error (expected (error $errno)))
  )

  ;;; Returns the MAC address of the local port
  (@interface func (export "mac")
    (result $error (expected $hardware_address (error $errno)))
  )

  ;;; Returns a list of all the IP addresses owned by the local port
  ;;; This function fills the output buffer as much as possible.
  ;;; If the buffer is not big enough then the nips address will be
  ;;; filled with the buffer size needed and the EOVERFLOW will be returned
  (@interface func (export "ip_list")
    ;;; The buffer where IP addresses will be stored
    (param $ips (@witx pointer $addr_cidr))
    (param $nips (@witx pointer $size))
    ;;; The number of IP addresses returned.
    (result $error (expected (error $errno)))
  )

  ;;; Adds a default gateway to the port
  (@interface func (export "gateway_set")
    ;;; IP address of the default gateway
    (param $ip $addr_ip)
    (result $error (expected (error $errno)))
  )

  ;;; Adds a new route to the local port
  (@interface func (export "route_add")
    (param $cidr $addr_cidr)
    (param $via_router $addr_ip)
    (param $preferred_until $option_timestamp)
    (param $expires_at $option_timestamp)
    (result $error (expected (error $errno)))
  )

  ;;; Removes an existing route from the local port
  (@interface func (export "route_remove")
    (param $cidr $addr_ip)
    (result $error (expected (error $errno)))
  )

  ;;; Clears all the routes in the local port
  (@interface func (export "route_clear")
    (result $error (expected (error $errno)))
  )

  ;;; Returns a list of all the routes owned by the local port
  ;;; This function fills the output buffer as much as possible.
  ;;; If the buffer is too small this will return EOVERFLOW and
  ;;; fill nroutes with the size of the buffer needed.
  (@interface func (export "route_list")
    ;;; The buffer where routes will be stored
    (param $routes (@witx pointer $route))
    (param $nroutes (@witx pointer $size))
    (result $error (expected (error $errno)))
  )

  ;;; Shut down socket send and receive channels.
  ;;; Note: This is similar to `shutdown` in POSIX.
  (@interface func (export "shutdown")
    (param $fd $fd)
    ;;; Which channels on the socket to shut down.
    (param $how $sdflags)
    (result $error (expected (error $errno)))
  )

  ;;; Returns the current status of a socket
  (@interface func (export "status")
    (param $fd $fd)
    (result $error (expected $sock_status (error $errno)))
  )

  ;;; Returns the local address to which the socket is bound.
  ;;;
  ;;; Note: This is similar to `getsockname` in POSIX
  ;;;
  ;;; When successful, the contents of the output buffer consist of an IP address,
  ;;; either IP4 or IP6.
  (@interface func (export "addr_local")
    ;;; Socket that the address is bound to
    (param $fd $fd)
    (result $error (expected $addr_port (error $errno)))
  )

  ;;; Returns the remote address to which the socket is connected to.
  ;;;
  ;;; Note: This is similar to `getpeername` in POSIX
  ;;;
  ;;; When successful, the contents of the output buffer consist of an IP address,
  ;;; either IP4 or IP6.
  (@interface func (export "addr_peer")
    ;;; Socket that the address is bound to
    (param $fd $fd)
    (result $error (expected $addr_port (error $errno)))
  )

  ;;; Create an endpoint for communication.
  ;;;
  ;;; creates an endpoint for communication and returns a file descriptor
  ;;; tor that refers to that endpoint. The file descriptor returned by a successful
  ;;; call will be the lowest-numbered file descriptor not currently open
  ;;; for the process.
  ;;;
  ;;; Note: This is similar to `socket` in POSIX using PF_INET
  (@interface func (export "open")
    ;;; Address family
    (param $af $address_family)
    ;;; Socket type, either datagram or stream
    (param $socktype $sock_type)
    ;;; The file descriptor of the socket that has been opened.
    (result $error (expected $fd (error $errno)))
  )

  ;;; Sets a particular socket setting
  ;;; Note: This is similar to `setsockopt` in POSIX for SO_REUSEADDR
  (@interface func (export "set_opt")
    ;;; Socket descriptor
    (param $fd $fd)
    ;;; Socket option to be set
    (param $sockopt $sock_option)
    ;;; Value to set the option to
    (param $flag $bool)
    (result $error (expected (error $errno)))
  )

  ;;; Retrieve status of particular socket seting
  ;;; Note: This is similar to `getsockopt` in POSIX for SO_REUSEADDR
  (@interface func (export "get_opt")
    ;;; Socket descriptor
    (param $fd $fd)
    ;;; Socket option to be retrieved
    (param $sockopt $sock_option)
    (result $error (expected $bool (error $errno)))
  )

  ;;; Sets how long the socket will linger
  (@interface func (export "set_linger")
    ;;; Socket descriptor
    (param $fd $fd)
    ;;; Value to set the linger to
    (param $linger $option_timestamp)
    (result $error (expected (error $errno)))
  )

  ;;; Retrieve how long the socket will linger for
  (@interface func (export "get_linger")
    ;;; Socket descriptor
    (param $fd $fd)
    (result $error (expected $option_timestamp (error $errno)))
  )

  ;;; Sets one of the timeouts on the socket
  (@interface func (export "set_timeout")
    ;;; Socket descriptor
    (param $fd $fd)
    ;;; Type of timeout to be changed
    (param $ty $timeout_type)
    ;;; Value to set the timeout to
    (param $timeout $timestamp)
    (result $error (expected (error $errno)))
  )

  ;;; Retrieve one of the timeouts on the socket
  (@interface func (export "get_timeout")
    ;;; Socket descriptor
    (param $fd $fd)
    ;;; Type of timeout to be retrieved
    (param $ty $timeout_type)
    (result $error (expected $timestamp (error $errno)))
  )

  ;;; Set TTL for this socket
  (@interface func (export "set_ttl")
    ;;; Socket descriptor
    (param $fd $fd)
    ;;; Time to live
    (param $ttl $size)
    (result $error (expected (error $errno)))
  )

  ;;; Retrieve the TTL for this socket
  (@interface func (export "get_ttl")
    ;;; Socket descriptor
    (param $fd $fd)
    (result $error (expected $size (error $errno)))
  )

  ;;; Set TTL for IPv4 multicast for this socket
  (@interface func (export "set_multicast_ttl_v4")
    ;;; Socket descriptor
    (param $fd $fd)
    ;;; Time to live
    (param $ttl $size)
    (result $error (expected (error $errno)))
  )

  ;;; Retrieve the TTL for IPv4 multicast for this socket
  (@interface func (export "get_multicast_ttl_v4")
    ;;; Socket descriptor
    (param $fd $fd)
    (result $error (expected $size (error $errno)))
  )

  ;;; Joins a particular multicast IPv4 group
  (@interface func (export "join_multicast_v4")
    ;;; Socket descriptor
    (param $fd $fd)
    ;;; Multicast group to joined
    (param $multiaddr $addr_ip4)
    ;;; Interface that will join
    (param $interface $addr_ip4)
    (result $error (expected (error $errno)))
  )

  ;;; Leaves a particular multicast IPv4 group
  (@interface func (export "leave_multicast_v4")
    ;;; Socket descriptor
    (param $fd $fd)
    ;;; Multicast group to leave
    (param $multiaddr $addr_ip4)
    ;;; Interface that will left
    (param $interface $addr_ip4)
    (result $error (expected (error $errno)))
  )

  ;;; Joins a particular multicast IPv6 group
  (@interface func (export "join_multicast_v6")
    ;;; Socket descriptor
    (param $fd $fd)
    ;;; Multicast group to joined
    (param $multiaddr $addr_ip6)
    ;;; Interface that will join
    (param $interface u32)
    (result $error (expected (error $errno)))
  )

  ;;; Leaves a particular multicast IPv6 group
  (@interface func (export "leave_multicast_v6")
    ;;; Socket descriptor
    (param $fd $fd)
    ;;; Multicast group to leave
    (param $multiaddr $addr_ip6)
    ;;; Interface that will left
    (param $interface u32)
    (result $error (expected (error $errno)))
  )

  ;;; Set size of receive buffer
  ;;; Note: This is similar to `setsockopt` in POSIX for SO_RCVBUF
  (@interface func (export "set_recv_buf_size")
    ;;; Socket descriptor
    (param $fd $fd)
    ;;; Buffer size
    (param $size $filesize)
    (result $error (expected (error $errno)))
  )

  ;;; Retrieve the size of the receive buffer
  ;;; Note: This is similar to `getsockopt` in POSIX for SO_RCVBUF
  (@interface func (export "get_recv_buf_size")
    ;;; Socket descriptor
    (param $fd $fd)
    (result $error (expected $filesize (error $errno)))
  )

  ;;; Set size of send buffer
  ;;; Note: This is similar to `setsockopt` in POSIX for SO_SNDBUF
  (@interface func (export "set_send_buf_size")
    ;;; Socket descriptor
    (param $fd $fd)
    ;;; Buffer size
    (param $size $filesize)
    (result $error (expected (error $errno)))
  )

  ;;; Retrieve the size of the send buffer
  ;;; Note: This is similar to `getsockopt` in POSIX for SO_SNDBUF
  (@interface func (export "get_send_buf_size")
    ;;; Socket descriptor
    (param $fd $fd)
    (result $error (expected $filesize (error $errno)))
  )

  ;;; Bind a socket
  ;;; Note: This is similar to `bind` in POSIX using PF_INET
  (@interface func (export "bind")
    ;;; File descriptor of the socket to be bind
    (param $fd $fd)
    ;;; Address to bind the socket to
    (param $addr $addr_port)
    (result $error (expected (error $errno)))
  )

  ;;; Listen for connections on a socket
  ;;;
  ;;; Polling the socket handle will wait until a connection
  ;;; attempt is made
  ;;;
  ;;; Note: This is similar to `listen`
  (@interface func (export "listen")
    ;;; File descriptor of the socket to be bind
    (param $fd $fd)
    ;;; Maximum size of the queue for pending connections
    (param $backlog $size)
    (result $error (expected (error $errno)))
  )
  
  ;;; Accept a new incoming connection.
  ;;; Note: This is similar to `accept` in POSIX.
  (@interface func (export "accept")
    ;;; The listening socket.
    (param $fd $fd)
    ;;; The desired values of the file descriptor flags.
    (param $flags $fdflags)
    ;;; New socket connection
    (result $error (expected (tuple $fd $addr_port) (error $errno)))
  )

  ;;; Initiate a connection on a socket to the specified address
  ;;; 
  ;;; Polling the socket handle will wait for data to arrive or for
  ;;; the socket status to change which can be queried via 'sock_status'
  ;;;
  ;;; Note: This is similar to `connect` in POSIX
  (@interface func (export "connect")
    ;;; Socket descriptor
    (param $fd $fd)
    ;;; Address of the socket to connect to
    (param $addr $addr_port)
    (result $error (expected (error $errno)))
  )

  ;;; Receive a message from a socket.
  ;;; Note: This is similar to `recv` in POSIX, though it also supports reading
  ;;; the data into multiple buffers in the manner of `readv`.
  (@interface func (export "recv")
    (param $fd $fd)
    ;;; List of scatter/gather vectors to which to store data.
    (param $ri_data $iovec_array)
    ;;; Message flags.
    (param $ri_flags $riflags)
    ;;; Number of bytes stored in ri_data and message flags.
    (result $error (expected (tuple $filesize $roflags) (error $errno)))
  )

  ;;; Receive a message and its peer address from a socket.
  ;;; Note: This is similar to `recvfrom` in POSIX, though it also supports reading
  ;;; the data into multiple buffers in the manner of `readv`.
  (@interface func (export "recv_from")
    (param $fd $fd)
    ;;; List of scatter/gather vectors to which to store data.
    (param $ri_data $iovec_array)
    ;;; Message flags.
    (param $ri_flags $riflags)
    ;;; Number of bytes stored in ri_data and message flags.
    (result $error (expected (tuple $filesize $roflags $addr_port) (error $errno)))
  )

  ;;; Send a message on a socket.
  ;;; Note: This is similar to `send` in POSIX, though it also supports writing
  ;;; the data from multiple buffers in the manner of `writev`.
  (@interface func (export "send")
    (param $fd $fd)
    ;;; List of scatter/gather vectors to which to retrieve data
    (param $si_data $ciovec_array)
    ;;; Message flags.
    (param $si_flags $siflags)
    ;;; Number of bytes transmitted.
    (result $error (expected $filesize (error $errno)))
  )

  ;;; Send a message on a socket to a specific address.
  ;;; Note: This is similar to `sendto` in POSIX, though it also supports writing
  ;;; the data from multiple buffers in the manner of `writev`.
  (@interface func (export "send_to")
    (param $fd $fd)
    ;;; List of scatter/gather vectors to which to retrieve data
    (param $si_data $ciovec_array)
    ;;; Message flags.
    (param $si_flags $siflags)
    ;;; Address of the socket to send message to
    (param $addr $addr_port)
    ;;; Number of bytes transmitted.
    (result $error (expected $filesize (error $errno)))
  )

  ;;; Resolves a hostname and a port to one or more IP addresses.
  ;;;
  ;;; Note: This is similar to `getaddrinfo` in POSIX
  ;;;
  ;;; When successful, the contents of the output buffer consist of a sequence of
  ;;; IPv4 and/or IPv6 addresses. Each address entry consists of a addr_t object.
  ;;
  ;;; This function fills the output buffer as much as possible.
  (@interface func (export "resolve")
    ;;; Host to resolve
    (param $host string)
    ;;; Port hint (zero if no hint is supplied)
    (param $port u16)
    ;;; The buffer where IP addresses will be stored
    (param $ips (@witx pointer $addr_ip))
    (param $nips $size)
    ;;; The number of IP addresses returned during the DNS resolution.
    (result $error (expected $size (error $errno)))
  )
)
